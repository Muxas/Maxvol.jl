var documenterSearchIndex = {"docs":
[{"location":"#Documentation-for-Maxvol-1","page":"Documentation for Maxvol","title":"Documentation for Maxvol","text":"","category":"section"},{"location":"#","page":"Documentation for Maxvol","title":"Documentation for Maxvol","text":"This Julia package provides four routines:","category":"page"},{"location":"#","page":"Documentation for Maxvol","title":"Documentation for Maxvol","text":"maxvol_generic!, generic implementation of Maxvol algorithm, which can be used for matrices of any numerical type (e.g. Rational or BigFloat).\nmaxvol!, LAPACK-based implementation of Maxvol algorithm, which works only for standard numerical types: Float32, Float64, ComplexF32 and ComplexF64.\nrect_maxvol_generic, generic implementation of Rect_maxvol algorithm, which can be used for matrices of any numerical type (e.g. Rational or  BigFloat).\nrect_maxvol, LAPACK-based implementation of Rect_maxvol algorithm, which works only for standard numerical types: Float32, Float64, ComplexF32 and ComplexF64.","category":"page"},{"location":"#Methods-1","page":"Documentation for Maxvol","title":"Methods","text":"","category":"section"},{"location":"#","page":"Documentation for Maxvol","title":"Documentation for Maxvol","text":"maxvol_generic!\nmaxvol!\nrect_maxvol_generic\nrect_maxvol","category":"page"},{"location":"#Maxvol.maxvol_generic!","page":"Documentation for Maxvol","title":"Maxvol.maxvol_generic!","text":"maxvol_generic!(A, tol=1.05, maxiters=100)\n\nGeneric maxvol method, that does not use any BLAS or LAPACK calls.\n\nFinds good square submatrix. Uses greedy iterative maximization of 1-volume to find good r-by-r submatrix in a given N-by-r matrix A of rank r. Returns good submatrix and coefficients of expansion (N-by-r matrix) of rows of matrix A by rows of good submatrix.\n\nCan be used for special arithmetics, like BigFloat, Rational or Complex{Float16}.\n\nArguments:\n\nA::Matrix: Input matrix on entry and output coefficients on exit.\ntol::Float64: Stop when determinant growth is less or equal to this.\nmaxiters::Int: Maximum number of iterations.\n\nReturns:\n\npiv::Vector{Int}: Indexes of pivoted rows\nniters::Int: Number of performed swap iterations\n\nExample:\n\njulia> using Random, LinearAlgebra, Maxvol\njulia> rng = MersenneTwister(100);\njulia> A = rand(rng, BigFloat, 1000, 100);\njulia> C = copy(A);\njulia> piv, niters = maxvol_generic!(C);\njulia> norm(A-C*A[piv,:]) / norm(A)\n2.030657951400512330834848952202721164346464876711701213634530270353170311161736e-76\njulia> A = rand(rng, ComplexF64, 1000, 100);\njulia> C = copy(A);\njulia> piv, niters = maxvol_generic!(C);\njulia> norm(A-C*A[piv,:]) / norm(A)\n4.863490630095799e-15\n\nSee also: maxvol!\n\n\n\n\n\n","category":"function"},{"location":"#Maxvol.maxvol!","page":"Documentation for Maxvol","title":"Maxvol.maxvol!","text":"maxvol!(A, tol=1.05, maxiters=100)\n\nFinds good square submatrix. Uses greedy iterative maximization of 1-volume to find good r-by-r submatrix in a given N-by-r matrix A of rank r. Returns good submatrix and coefficients of expansion (N-by-r matrix) of rows of matrix A by rows of good submatrix.\n\nUses vendor-optimized LAPACK, provided by Julia. Supports only 4 input types: Float32 (single), Float64 (double), ComplexF32 (single complex) and ComplexF64 (double complex).\n\nArguments:\n\nA::Matrix{T}: Input matrix on entry and output coefficients on exit. T   must be one of Float32, Float64, ComplexF32 and ComplexF64.\ntol::Float64: Stop when determinant growth is less or equal to this.\nmaxiters::Int: Maximum number of iterations.\n\nReturns:\n\npiv::Vector{Int}: Indexes of pivoted rows\nniters::Int: Number of performed swap iterations\n\nExample:\n\njulia> using Random, LinearAlgebra, Maxvol\njulia> rng = MersenneTwister(100);\njulia> A = rand(rng, Float64, 1000, 100);\njulia> C = copy(A);\njulia> piv, niters = maxvol!(C);\njulia> norm(A-C*A[piv,:]) / norm(A)\n2.3975097489579994e-15\njulia> A = rand(rng, ComplexF32, 1000, 100);\njulia> C = copy(A);\njulia> piv, niters = maxvol!(C);\njulia> norm(A-C*A[piv,:]) / norm(A)\n2.0852597f-6\n\nSee also: maxvol_generic!\n\n\n\n\n\n","category":"function"},{"location":"#Maxvol.rect_maxvol_generic","page":"Documentation for Maxvol","title":"Maxvol.rect_maxvol_generic","text":"rect_maxvol_generic(A, tol=1.0, maxK=size(A,1), min_add_K=0,\n    min_K=size(A,2), start_maxvol_iters=10, identity_submatrix=true)\n\nGeneric rect_maxvol method, that does not call BLAS or LAPACK directly.\n\nFinds good rectangular submatrix. Uses greedy iterative maximization of 2-volume to find good K-by-r submatrix in a given N-by-r matrix A of rank r. Returns good submatrix and least squares coefficients of expansion (N-by-K matrix) of rows of matrix A by rows of good submatrix.\n\nCan be used for special arithmetics, like BigFloat, Rational or Complex{Float16}.\n\nArguments:\n\nA::Matrix: Input matrix on entry.\ntol::Float64: Stop when volume growth is less or equal to this.\nmaxK::Int: Maximum number of rows in good submatrix.\nminK::Int: Minimum number of rows in good submatrix.\nmin_add_K::Int: Minimum number of rows to add to the square submatrix.       Resulting good matrix will have minimum of r+min_add_K rows.\nstart_maxvol_iters::Int: How many iterations of square maxvol (optimization       of 1-volume) is required to be done before actual rectangular 2-volume       maximization.\nidentity_submatrix::Bool: Coefficients of expansions are computed as least       squares solution. If identity_submatrix is True, returned matrix of       coefficients will have submatrix, corresponding to good rows,       set to identity.\n\nReturns:\n\npiv::Vector{Int}: Indexes of pivoted rows\nC::Matrix: N-by-size(piv) matrix of coefficients of expansion of all rows       of A by `good'' rowspiv`.\n\nExample:\n\njulia> using Random, LinearAlgebra, Maxvol\njulia> rng = MersenneTwister(100);\njulia> A = rand(rng, BigFloat, 1000, 100);\njulia> piv, C = rect_maxvol_generic(A);\njulia> norm(A-C*A[piv,:]) / norm(A)\n1.487413551535496062888389670275572427766752748825675538705145867354156169433079e-76\njulia> A = rand(rng, ComplexF64, 1000, 100);\njulia> piv, C = rect_maxvol_generic(A);\njulia> norm(A-C*A[piv,:]) / norm(A)\n3.5140903782712447e-15\n\nSee also: rect_maxvol\n\n\n\n\n\n","category":"function"},{"location":"#Maxvol.rect_maxvol","page":"Documentation for Maxvol","title":"Maxvol.rect_maxvol","text":"rect_maxvol(A, tol=1.0, maxK=size(A,1), min_add_K=0, min_K=size(A,2),\n    start_maxvol_iters=10, identity_submatrix=true)\n\nFinds good rectangular submatrix. Uses greedy iterative maximization of 2-volume to find good K-by-r submatrix in a given N-by-r matrix A of rank r. Returns good submatrix and least squares coefficients of expansion (N-by-K matrix) of rows of matrix A by rows of good submatrix.\n\nUses vendor-optimized LAPACK, provided by Julia. Supports only 4 input types: Float32 (single), Float64 (double), ComplexF32 (single complex) and ComplexF64 (double complex).\n\nArguments:\n\nA::Matrix: Input matrix on entry.\ntol::Float64: Stop when volume growth is less or equal to this.\nmaxK::Int: Maximum number of rows in good submatrix.\nminK::Int: Minimum number of rows in good submatrix.\nmin_add_K::Int: Minimum number of rows to add to the square submatrix.       Resulting good matrix will have minimum of r+min_add_K rows.\nstart_maxvol_iters::Int: How many iterations of square maxvol (optimization       of 1-volume) is required to be done before actual rectangular 2-volume       maximization.\nidentity_submatrix::Bool: Coefficients of expansions are computed as least       squares solution. If identity_submatrix is True, returned matrix of       coefficients will have submatrix, corresponding to good rows,       set to identity.\n\nReturns:\n\npiv::Vector{Int}: Indexes of pivoted rows\nC::Matrix: N-by-size(piv) matrix of coefficients of expansion of all rows       of A by `good'' rowspiv`.\n\nExample:\n\njulia> using Random, LinearAlgebra, Maxvol\njulia> rng = MersenneTwister(100);\njulia> A = rand(rng, Float64, 1000, 100);\njulia> piv, C = rect_maxvol(A);\njulia> norm(A-C*A[piv,:]) / norm(A)\n1.8426360389674326e-15\njulia> A = rand(rng, ComplexF32, 1000, 100);\njulia> piv, C = rect_maxvol(C);\njulia> norm(A-C*A[piv,:]) / norm(A)\n1.8014168f-6\n\nSee also: rect_maxvol_generic\n\n\n\n\n\n","category":"function"},{"location":"#License-1","page":"Documentation for Maxvol","title":"License","text":"","category":"section"},{"location":"#","page":"Documentation for Maxvol","title":"Documentation for Maxvol","text":"This package is ditributed under BSD 3-Clause license. It can be found in the root directory of repository in LICENSE.md file.","category":"page"}]
}
